BubbleSort:
        cmp     r1, #1            // Сравниваем количество элементов (r1) с 1
        beq     .L8                // Если количество элементов <= 1, переходим к метке .L8 (выход)
        push    {r4, r5, r6, lr}   // Сохраняем регистры r4, r5, r6 и адрес возврата (lr) в стеке
        mov     r6, r0             // r6 = адрес массива (r0)
        mov     r5, r1             // r5 = количество элементов (r1)
        sub     ip, r0, #8         // ip = адрес последнего элемента массива
        add     ip, ip, r1, lsl #3  // ip = адрес последнего элемента массива (r0 + (r1 * 8))
.L3:
        mov     r3, r6             // r3 = адрес начала массива
.L5:
        ldr     r1, [r3]           // Загружаем элемент массива в r1
        ldr     r2, [r3, #4]       // Загружаем следующий элемент в r2
        ldr     r4, [r3, #8]!      // Загружаем элемент через 2 позиции (в r4) и обновляем адрес в r3
        ldr     r0, [r3, #4]       // Загружаем элемент в r0 (это повторная загрузка значения из r2)
        cmp     r4, r1             // Сравниваем элементы r4 и r1
        sbcs    lr, r0, r2         // Если r4 < r1, сохраняем результат сравнения в lr
        itttt   lt                  // Условная инструкция: если меньше
        strlt   r4, [r3, #-8]      // Если нужно, сохраняем значение из r4 на место элемента [r3 - 8]
        strlt   r0, [r3, #-4]      // Если нужно, сохраняем значение из r0 на место элемента [r3 - 4]
        strlt   r1, [r3]           // Если нужно, сохраняем значение из r1 на место элемента [r3]
        strlt   r2, [r3, #4]       // Если нужно, сохраняем значение из r2 на место элемента [r3 + 4]
        cmp     r3, ip             // Проверяем, достигли ли конца массива
        bne     .L5                // Если не достигли конца массива, продолжаем сортировку
        subs    r5, r5, #1         // Уменьшаем счетчик проходов по массиву
        sub     ip, ip, #8         // Обновляем адрес последнего элемента для следующего прохода
        cmp     r5, #1             // Проверяем количество оставшихся элементов
        bne     .L3                // Если больше 1 элемента остался, продолжаем сортировку
        pop     {r4, r5, r6, pc}   // Восстанавливаем регистры и возвращаемся из функции
.L8:
        bx      lr                 // Возвращаемся из функции
.LC0:
        .ascii  "r000"            // Строка для чтения данных (формат)
.LC1:
        .ascii  "test.txt000"     // Имя файла для чтения
.LC2:
        .ascii  "%llu000"         // Формат для scanf
main:
        push    {r4, r5, r6, r7, r8, r9, lr}  // Сохраняем регистры в стеке
        sub     sp, sp, #12         // Выделяем место в стеке
        movw    r3, #:lower16:stdin  // Загружаем адрес stdin в r3
        movt    r3, #:upper16:stdin
        ldr     r2, [r3]            // Загружаем указатель на stdin
        movw    r1, #:lower16:.LC0   // Загружаем адрес строки формата в r1
        movt    r1, #:upper16:.LC0
        movw    r0, #:lower16:.LC1   // Загружаем адрес имени файла в r0
        movt    r0, #:upper16:.LC1
        bl      freopen             // Открываем файл для чтения с помощью freopen
        mov     r7, r0              // Сохраняем указатель на FILE* в r7
        add     r2, sp, #4          // Указываем место в стеке для хранения данных
        movw    r1, #:lower16:.LC2   // Загружаем адрес формата для scanf в r1
        movt    r1, #:upper16:.LC2
        bl      __isoc99_fscanf     // Читаем количество элементов из файла
        ldr     r6, [sp, #4]        // Загружаем количество элементов в r6
        lsls    r0, r6, #3          // Умножаем количество элементов на 8 (размер типа long long)
        bl      malloc               // Выделяем память под массив
        mov     r9, r0              // Сохраняем указатель на выделенную память в r9
        cbz     r6, .L12            // Если количество элементов равно 0 - переходим к .L12
        mov     r5, r0              // Устанавливаем указатель на массив в r5
        movs    r4, #0               // Устанавливаем счетчик элементов в 0
        movw    r8, #:lower16:.LC2   // Загружаем адрес формата для scanf в r8
        movt    r8, #:upper16:.LC2
.L13:
        mov     r2, r5              // Устанавливаем указатель на массив в р2
        mov     r1, r8              // Устанавливаем формат для scanf в р1
        mov     r0, r7              // Устанавливаем FILE* в р0
        bl      __isoc99_fscanf      // Читаем элемент из файла в массив
        adds    r4, r4, #1          // Увеличиваем счетчик элементов на 1
        ldr     r6, [sp, #4]         // Загружаем количество элементов снова в r6
        adds    r5, r5, #8          // Переходим к следующему элементу массива (размер long long)
        cmp     r6, r4              // Сравниваем прочитанные элементы с количеством ожидаемых элементов
        bhi     .L13                // Если еще есть элементы для чтения - продолжаем цикл
.L12:
        mov     r1, r6              // Передаем количество элементов в BubbleSort
        mov     r0, r9              // Передаем указатель на массив в BubbleSort
        bl      BubbleSort          // Вызываем функцию сортировки пузырьком
        mov     r0, r9              // Передаем указатель на массив для освобождения памяти
        bl      free                 // Освобождаем память
        movs    r0, #0               // Возвращаем 0 как статус завершения программы
        add     sp, sp, #12         // Восстанавливаем стек после вызова main
        pop     {r4, r5, r6, r7, r8, r9, pc}  // Восстанавливаем регистры и возвращаемся из main