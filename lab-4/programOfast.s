BubbleSort:
        cmp     r1, #1            // Сравниваем количество элементов (r1) с 1
        beq     .L12               // Если количество элементов <= 1, переходим к метке .L12 (выход)
        sub     ip, r0, #8         // ip = адрес последнего элемента массива (r0 - 8)
        push    {r4, r5, r6, lr}   // Сохраняем регистры r4, r5, r6 и адрес возврата (lr) в стеке
        add     ip, ip, r1, lsl #3  // ip = адрес конца массива (r0 + (r1 * 8))
        mov     r5, r1             // r5 = количество элементов (r1)
        mov     r6, r0             // r6 = адрес массива (r0)
.L5:
        mov     r3, r6             // Устанавливаем указатель на начало массива в r3
.L4:
        ldrd    r1, r2, [r3]       // Загружаем два элемента массива в r1 и r2
        ldr     r4, [r3, #8]!      // Загружаем следующий элемент в r4 и обновляем указатель r3
        cmp     r4, r1             // Сравниваем элементы r4 и r1
        ldr     r0, [r3, #4]       // Загружаем элемент из следующей позиции в r0
        sbcs    lr, r0, r2         // Если r4 < r1, сохраняем результат сравнения в lr
        itt     lt                  // Условная инструкция: если меньше
        strdlt  r4, r0, [r3, #-8]   // Если нужно, сохраняем значение из r4 на место элемента [r3 - 8]
        strdlt  r1, r2, [r3]       // Если нужно, сохраняем значение из r1 на место элемента [r3]
        cmp     ip, r3             // Проверяем, достигли ли конца массива
        bne     .L4                // Если не достигли конца массива, продолжаем сортировку
        subs    r5, r5, #1         // Уменьшаем счетчик проходов по массиву
        sub     ip, ip, #8         // Обновляем адрес последнего элемента для следующего прохода
        cmp     r5, #1             // Проверяем количество оставшихся элементов
        bne     .L5                // Если больше 1 элемента остался, продолжаем сортировку
        pop     {r4, r5, r6, pc}   // Восстанавливаем регистры и возвращаемся из функции
.L12:
        bx      lr                 // Возвращаемся из функции
.LC0:
        .ascii  "r000"            // Строка для чтения данных (формат)
.LC1:
        .ascii  "test.txt000"     // Имя файла для чтения
.LC2:
        .ascii  "%llu000"         // Формат для scanf
main:
        push    {r4, r5, r6, r7, r8, r9, lr}  // Сохраняем регистры в стеке
        movw    r3, #:lower16:stdin  // Загружаем адрес stdin в r3
        movt    r3, #:upper16:stdin
        sub     sp, sp, #12          // Выделяем место в стеке
        movw    r1, #:lower16:.LC0    // Загружаем адрес строки формата в r1
        movt    r1, #:upper16:.LC0
        movw    r0, #:lower16:.LC1    // Загружаем адрес имени файла в r0
        movt    r0, #:upper16:.LC1
        ldr     r2, [r3]             // Загружаем указатель на stdin
        bl      freopen              // Открываем файл для чтения с помощью freopen
        add     r2, sp, #4           // Указываем место в стеке для хранения данных
        movw    r1, #:lower16:.LC2    // Загружаем адрес формата для scanf в r1
        movt    r1, #:upper16:.LC2
        mov     r7, r0               // Сохраняем указатель на FILE* в r7
        bl      __isoc99_fscanf      // Читаем количество элементов из файла
        ldr     r6, [sp, #4]         // Загружаем количество элементов в r6
        lsls    r0, r6, #3           // Умножаем количество элементов на 8 (размер типа long long)
        bl      malloc               // Выделяем память под массив
        mov     r9, r0               // Сохраняем указатель на выделенную память в r9
        cbz     r6, .L17             // Если количество элементов равно 0 - переходим к .L17
        movw    r8, #:lower16:.LC2    // Загружаем адрес формата для scanf в r8
        movt    r8, #:upper16:.LC2
        mov     r5, r0               // Устанавливаем указатель на массив в r5
        movs    r4, #0                // Устанавливаем счетчик элементов в 0
.L18:
        mov     r2, r5               // Устанавливаем указатель на массив в р2
        mov     r1, r8               // Устанавливаем формат для scanf в р1
        mov     r0, r7               // Устанавливаем FILE* в р0
        adds    r4, r4, #1           // Увеличиваем счетчик элементов на 1
        bl      __isoc99_fscanf      // Читаем элемент из файла в массив
        ldr     r6, [sp, #4]         // Загружаем количество элементов снова в r6
        adds    r5, r5, #8           // Переходим к следующему элементу массива (размер long long)
        cmp     r6, r4               // Сравниваем прочитанные элементы с количеством ожидаемых элементов
        bhi     .L18                 // Если еще есть элементы для чтения - продолжаем цикл
.L17:
        mov     r1, r6               // Передаем количество элементов в BubbleSort
        mov     r0, r9               // Передаем указатель на массив в BubbleSort
        bl      BubbleSort           // Вызываем функцию сортировки пузырьком
        mov     r0, r9               // Передаем указатель на массив для освобождения памяти
        bl      free                 // Освобождаем память
        movs    r0, #0                // Возвращаем 0 как статус завершения программы
        add     sp, sp, #12          // Восстанавливаем стек после вызова main
        pop     {r4, r5, r6, r7, r8, r9, pc}  // Восстанавливаем регистры и возвращаемся из main