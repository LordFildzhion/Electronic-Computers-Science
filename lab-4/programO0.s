swap:
        push    {r7}                // Сохраняем r7 в стек
        sub     sp, sp, #20         // Выделяем место в стеке для локальных переменных
        add     r7, sp, #0          // Устанавливаем указатель кадра стека
        str     r0, [r7, #4]        // Сохраняем r0 (первый указатель) в стек
        str     r1, [r7]            // Сохраняем r1 (второй указатель) в стек
        ldr     r3, [r7, #4]        // Загружаем указатель первого элемента в r3
        ldrd    r2, [r3]            // Загружаем 64-битное значение из памяти по адресу r3
        strd    r2, [r7, #8]        // Сохраняем это значение в стек
        ldr     r3, [r7]            // Загружаем указатель второго элемента в r3
        ldrd    r2, [r3]            // Загружаем 64-битное значение второго элемента
        ldr     r1, [r7, #4]        // Загружаем указатель первого элемента
        strd    r2, [r1]            // Копируем значение второго элемента на место первого
        ldr     r1, [r7]            // Загружаем указатель второго элемента
        ldrd    r2, [r7, #8]        // Загружаем сохраненное значение первого элемента
        strd    r2, [r1]            // Копируем значение первого элемента на место второго
        nop
        adds    r7, r7, #20         // Восстанавливаем указатель стека
        mov     sp, r7              // Восстанавливаем стек
        ldr     r7, [sp], #4        // Восстанавливаем r7 из стека
        bx      lr                  // Возврат из функции
BubbleSort:
        push    {r7, lr}            // Сохраняем r7 и адрес возврата
        sub     sp, sp, #16         // Выделяем место для локальных переменных
        add     r7, sp, #0          // Устанавливаем указатель кадра стека
        str     r0, [r7, #4]        // Сохраняем указатель массива в стек
        str     r1, [r7]            // Сохраняем размер массива в стек
        movs    r3, #0              // Инициализируем внешний счетчик (r3 = 0)
        str     r3, [r7, #12]       // Сохраняем внешний счетчик в стек
        b       .L3                 // Переход к началу внешнего цикла
.L7:
        movs    r3, #0              // Инициализируем внутренний счетчик (r3 = 0)
        str     r3, [r7, #8]        // Сохраняем внутренний счетчик в стек
        b       .L4                 // Переход к внутреннему циклу
.L6:
        ldr     r3, [r7, #8]        // Загружаем внутренний счетчик
        lsls    r3, r3, #3          // Умножаем внутренний счетчик на 8 (размер элемента)
        ldr     r2, [r7, #4]        // Загружаем указатель массива
        add     r3, r3, r2          // Вычисляем адрес текущего элемента
        ldrd    r2, [r3]            // Загружаем текущее значение (64 бита)
        ldr     r1, [r7, #8]        // Загружаем внутренний счетчик
        adds    r1, r1, #1          // Переходим к следующему элементу
        lsls    r1, r1, #3          // Умножаем на 8 (размер элемента)
        ldr     r0, [r7, #4]        // Загружаем указатель массива
        add     r1, r1, r0          // Вычисляем адрес следующего элемента
        ldrd    r0, [r1]            // Загружаем значение следующего элемента (64 бита)
        cmp     r0, r2              // Сравниваем текущий и следующий элементы
        sbcs    r3, r1, r3          // Вычитаем из r1 r3, результат записываем в r3
        bge     .L5                 // Если порядок правильный, пропускаем обмен
        ldr     r3, [r7, #8]        // Загружаем внутренний счетчик
        lsls    r3, r3, #3          // Умножаем на 8
        ldr     r2, [r7, #4]        // Загружаем указатель массива
        adds    r0, r2, r3          // Адрес текущего элемента
        ldr     r3, [r7, #8]        // Загружаем внутренний счетчик
        adds    r3, r3, #1          // Следующий элемент
        lsls    r3, r3, #3          // Умножаем на 8
        ldr     r2, [r7, #4]        // Загружаем указатель массива
        add     r3, r3, r2          // Адрес следующего элемента
        mov     r1, r3              // Устанавливаем адрес следующего элемента
        bl      swap                // Вызываем функцию для обмена элементов
.L5:
        ldr     r3, [r7, #8]        // Загружаем внутренний счетчик
        adds    r3, r3, #1          // Увеличиваем внутренний счетчик
        str     r3, [r7, #8]        // Сохраняем его в стек
.L4:
        ldr     r2, [r7]            // Загружаем размер массива
        ldr     r3, [r7, #12]       // Загружаем внешний счетчик
        subs    r3, r2, r3          // Сравниваем с размером массива
        subs    r3, r3, #1          // Уменьшаем на 1
        ldr     r2, [r7, #8]        // Загружаем внутренний счетчик
        cmp     r2, r3              // Сравниваем с концом
        bcc     .L6                 // Переход, если не достигли конца
        ldr     r3, [r7, #12]       // Загружаем внешний счетчик
        adds    r3, r3, #1          // Увеличиваем внешний счетчик
        str     r3, [r7, #12]       // Сохраняем в стек
.L3:
        ldr     r3, [r7]            // Загружаем размер массива
        subs    r3, r3, #1          // Уменьшаем на 1
        ldr     r2, [r7, #12]       // Загружаем внешний счетчик
        cmp     r2, r3              // Сравниваем с концом
        bcc     .L7                 // Переход, если не достигли конца
        nop
        nop
        adds    r7, r7, #16         // Восстанавливаем указатель стека
        mov     sp, r7              // Восстанавливаем стек
        pop     {r7, pc}            // Восстанавливаем r7 и возвращаемся
.LC0:
        .ascii  "r\000"            // Строка "r" (режим чтения файла)
.LC1:
        .ascii  "test.txt\000"     // Строка "test.txt" (имя файла)
.LC2:
        .ascii  "%llu\000"         // Формат для чтения unsigned long long
main:
        push    {r7, lr}           // Сохраняем r7 и адрес возврата
        sub     sp, sp, #16        // Выделяем место для локальных переменных
        add     r7, sp, #0         // Устанавливаем указатель кадра стека
        movw    r3, #:lower16:stdin // Загружаем младшие 16 бит адреса stdin
        movt    r3, #:upper16:stdin // Загружаем старшие 16 бит адреса stdin
        ldr     r3, [r3]           // Получаем указатель на stdin
        mov     r2, r3             // Сохраняем указатель в r2
        movw    r1, #:lower16:.LC0 // Загружаем младшие 16 бит строки "r"
        movt    r1, #:upper16:.LC0 // Загружаем старшие 16 бит строки "r"
        movw    r0, #:lower16:.LC1 // Загружаем младшие 16 бит строки "test.txt"
        movt    r0, #:upper16:.LC1 // Загружаем старшие 16 бит строки "test.txt"
        bl      freopen            // Перенаправляем поток stdin на файл "test.txt"
        str     r0, [r7, #8]       // Сохраняем результат freopen
        mov     r3, r7             // Загружаем указатель кадра стека в r3
        mov     r2, r3             // Копируем в r2
        movw    r1, #:lower16:.LC2 // Загружаем младшие 16 бит строки "%llu"
        movt    r1, #:upper16:.LC2 // Загружаем старшие 16 бит строки "%llu"
        ldr     r0, [r7, #8]       // Загружаем указатель на поток
        bl      __isoc99_fscanf    // Читаем из файла значение в формате unsigned long long
        ldr     r3, [r7]           // Загружаем считанное значение (размер массива)
        lsls    r3, r3, #3         // Умножаем на 8 (размер одного элемента)
        mov     r0, r3             // Передаем размер массива для выделения памяти
        bl      malloc             // Выделяем память для массива
        mov     r3, r0             // Сохраняем указатель на массив
        str     r3, [r7, #4]       // Сохраняем в стек
        movs    r3, #0             // Инициализируем счетчик (индекс массива)
        str     r3, [r7, #12]      // Сохраняем счетчик в стек
        b       .L9                // Переход к циклу чтения элементов массива
.L10:
        ldr     r3, [r7, #12]      // Загружаем текущий индекс массива
        lsls    r3, r3, #3         // Умножаем индекс на 8
        ldr     r2, [r7, #4]       // Загружаем указатель массива
        add     r3, r3, r2         // Вычисляем адрес текущего элемента
        mov     r2, r3             // Копируем адрес в r2
        movw    r1, #:lower16:.LC2 // Загружаем младшие 16 бит строки "%llu"
        movt    r1, #:upper16:.LC2 // Загружаем старшие 16 бит строки "%llu"
        ldr     r0, [r7, #8]       // Загружаем указатель на поток
        bl      __isoc99_fscanf    // Читаем следующий элемент массива
        ldr     r3, [r7, #12]      // Загружаем текущий индекс массива
        adds    r3, r3, #1         // Увеличиваем индекс
        str     r3, [r7, #12]      // Сохраняем обновленный индекс в стек
.L9:
        ldr     r3, [r7]           // Загружаем размер массива
        ldr     r2, [r7, #12]      // Загружаем текущий индекс
        cmp     r2, r3             // Проверяем, достигли ли конца массива
        bcc     .L10               // Если нет, продолжаем цикл
        ldr     r3, [r7]           // Загружаем размер массива
        mov     r1, r3             // Передаем размер массива в r1
        ldr     r0, [r7, #4]       // Передаем указатель массива в r0
        bl      BubbleSort         // Вызываем функцию сортировки
        ldr     r0, [r7, #4]       // Загружаем указатель массива
        bl      free               // Освобождаем выделенную память
        movs    r3, #0             // Устанавливаем код возврата 0
        mov     r0, r3             // Передаем код возврата
        adds    r7, r7, #16        // Восстанавливаем указатель кадра стека
        mov     sp, r7             // Сбрасываем стек
        pop     {r7, pc}           // Восстанавливаем r7 и возвращаемся